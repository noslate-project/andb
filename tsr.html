<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">
<html><head>
<style type="text/css"><!--
body {background-color: #ffffff; color: #000000;}
body, td, th, h1, h2, h3 {font-family: sans-serif;}
pre {margin: 0px; font-family: monospace;}
a:link {color: #000099; text-decoration: none; background-color: #ffffff;}
a:hover {text-decoration: underline;}
table {border-collapse: collapse;}
.center {text-align: center;}
.center table { margin-left: auto; margin-right: auto; text-align: left;}
.center th { text-align: center !important; }
td, th { border: 1px solid #000000; font-size: 75%; vertical-align: baseline; min-width: 30px; }
h1 {font-size: 150%;}
h2 {font-size: 125%;}
h3 {font-size: 100%;}
.p {text-align: left;}
.e {background-color: #ccccff; font-weight: bold; color: #000000;}
.h {background-color: #9999cc; font-weight: bold; color: #000000;}
.v {background-color: #cccccc; color: #000000;}
i {color: #666666; background-color: #cccccc;}
img {float: right; border: 0px;}
hr {width: 600px; background-color: #cccccc; border: 0px; height: 1px; color: #000000;}
.navbar { position: fixed; top: 10px; left: 10px; z-index: 100; border: 1px solid #e0e0e0; background-color: #ffffff; opacity:0.3;}
.navbar a { margin-left: 3px; margin-right: 3px; font-size: 75%;}
//--></style>
<title>Noslate Debugger Report</title></head>
<body><div class="center">
<table border="0" cellpadding="3" width="600">
<tr class="h"><td>
<a href="https://noslate.midwayjs.org/"><img border="0" src="https://noslate.midwayjs.org/img/logo.svg" alt="Noslate Logo" width="48"/></a><h1 class="p">Noslate Debugger Corefile Report</h1>
</td></tr>
</table><br />
<div id="load-box" style="display:none">
<table border="0" cellpadding="3" width="600">
<tr class="h">
<td class="e"><label for="tsr-input" id="tsr-input-label">Load report</label></td>
<td class="v"><input type="file" id="tsr-input" accept=".tsr" /></td>
</tr>
</table><br />
</div>
<div id="contents"></div>
<br />
<table border="0" cellpadding="3" width="600">
<tr class="v"><td>
<p> The report file was generated by Noslate Debugger.
</p>
<p> https://noslate.midwayjs.org
</p>
</td></tr>
</table><br />
</div>
<div class="navbar" id="navbar" style="display: none;">
    <a href="#">Top</a><br />
    <a href="#v8_backtrace">V8 Backtrace</a><br />
    <a href="#isolates">Isolates</a><br />
    <a href="#environ_variables">Environ Variables</a><br />
    <a href="#nt_files">Load Files</a><br />
    <a href="#mmap">Memory Maps</a><br />
</div>
</body>

<script type="text/javascript">
const urlParams = new URLSearchParams(window.location.search);
const tsr_url = urlParams.get('tsr')
if (tsr_url != null) {
    document.querySelector("#contents").innerHTML = "<p>loading... </p>";
    document.querySelector("#contents").style.display = 'block';
    fetch(tsr_url).then(response => response.text()).then((text) => {
        document.querySelector("#contents").innerHTML = LoadTsr(text);
    });
    /*.catch(rejected => {
        console.log('failed to fetch tsr URL');
        document.querySelector("#contents").innerHTML = "<p>tsr not loaded.</p>";
        document.querySelector("#contents").style.display = 'block';
    })*/
} else {
    document.querySelector("#load-box").style.display = 'block';
}

function toTag(name) {
    return name.replace(/ /g, "_").toLowerCase();
}

function thX(...v) {
    let html = '<tr class="h">';
    v.forEach((el) => {
        html += '<th class="">' + el + '</th>'
    });
    return html + '</tr>';
}

function tdX(name, ...v) {
    let html = '<tr><td class="e">' + name + '</td>'
    v.forEach(el => {
        html += '<td class="v">' + el + '</td>'
    });
    return html + '</tr>';
}

function xp(tsr, path, def=undefined) {
    let x = tsr;
    try {
        path.split('/').forEach((v) => {
            if (!x.hasOwnProperty(v)) 
                throw "no such key";
            x = x[v]
        });
        return x;
    } catch (e) {
        // nothing
    }
    return def;
}

function hex(x) {
    if (x == undefined) return "";
    return '0x' + x.toString(16);
}

function escapeHtml(unsafe) {
    return unsafe
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
 }

 class TSR {
    constructor(txt) {
        this.tsr = JSON.parse(txt);
        this.mmap = this._loadMmap();
    }

    _loadMmap() {
        const x = xp(this.tsr, 'core/mmap');
        if (x == undefined) return [];
        return x;
    }
    
    mMapNote(start_addr, end_addr, name) {
        for (let el of this.mmap) {
            const block_start = el['p_vaddr'];
            const block_end = block_start + el['p_memsz'];
            if (block_start == block_end)
                continue;
            if (end_addr < block_start)
                break;
            if ((block_start <= start_addr && start_addr < block_end) ||
                (block_start <= end_addr && end_addr < block_end) ||
                (start_addr <= block_start && block_start < end_addr) ||
                (start_addr <= block_end && block_end < end_addr)) {
                el['note'] = name;
            }
        }
    }

    _list(root, blk, title=undefined) {
        let html = '';
    }

    _dict(tsr, blk=undefined) {
        let html = '';
        let o = blk ? tsr[blk] : tsr;
        Object.keys(o).sort().forEach((k) =>{
            if (Object.prototype.toString.call(o[k]) === '[object Object]') {
                html += this._dict(o, k);
            } else if (Array.isArray(o[k])) {
                html += this._list(o, k);
            } else {
                html += tdX(k, o[k]);
            }
        });
        return html;
    }

    rDictX(xpath, title) {
        let x = xp(this.tsr, xpath);
        if (x == undefined) return '';
        let html = ``;
        html += `<h2 id="${toTag(title)}">${title}</h2>`;
        html += '<table border="0" cellpadding="3" width="600">';
        html += this._dict(x);
        html += '</table><br />';
        return html;       
    }

    rCoreNtFiles() {
        const x = xp(this.tsr, 'core/files');
        if (x == undefined) return '';
        let html = '<h2 id="nt_files"}>NT_FILES</h2>';
        html += '<table border="0" cellpadding="3" width="600">';
        html += thX('', 'start_addr', 'end_addr', 'name', 'build_id');
        x.forEach((el, idx) => {
            html += tdX(idx, hex(el['start_addr']), hex(el['end_addr']), el['name'], el['build_id']);
            this.mMapNote(el['start_addr'], el['end_addr'], el['name']);
        });
        html += '</table><br />';
        return html;
    }

    rCoreMMap() {
        const x = this.mmap;
        if (x == undefined) return '';
        let html = '<h2 id="mmap"}>Memory Maps</h2>';
        html += '<table border="0" cellpadding="3" width="800">';
        html += thX('#', 'start_addr', 'end_addr', 'flag', 'type', 'size', 'note');
        const flag_str = (v) => {
            let out = "";
            out += v&4 ? 'r' : '-'; 
            out += v&2 ? 'w' : '-'; 
            out += v&1 ? 'x' : '-'; 
            out += v&8 ? 's' : 'p'; 
            return out;
        };
        x.forEach((el,idx) => {
            let end_addr = el['p_vaddr'] + el['p_memsz'];
            html += tdX(idx, hex(el['p_vaddr']), hex(end_addr), flag_str(el['p_flags']),  el['p_type'], el['p_memsz'], el['note']??"");
        }); 
        html += '</table><br />';
        return html;
    }

    rCore() {
        if (!('core' in this.tsr)) {
            return;
        }
        const core = this.tsr['core'];
        let html = '<h1>Corefile details</h1>';
        html += this.rDictX('core/siginfo', 'NT_SIGINFO');
        html += this.rDictX('core/prstatus', 'NT_PRSTATUS');
        html += this.rDictX('core/prpsinfo', 'NT_PRPSINFO');
        html += this.rCoreNtFiles();
        html += this.rCoreMMap();
        return html;
    }

    rFile() {
        const tsr = this.tsr;
        let html = '<h1>' + tsr['tsr_file'] + '</h1>';
        html += '<table border="0" cellpadding="3" width="600">';
        html += tdX('Create Time', tsr['create_time']);
        html += tdX('File Name', tsr['file']['name']);
        html += tdX('File Size', tsr['file']['size']);
        html += tdX('File MD5', tsr['file']['md5']);
        html += '</table><br />';
        return html;
    }
   
    rAndbNodeVersion() {
        return this.rDictX('andb/node_version', 'Node Version');
    }

    rAndbV8BackTrace() {
        const x = xp(this.tsr, 'andb/frames');
        if (x == undefined) return '';
        let html = '<h2 id="v8_backtrace">V8 Backtrace</h2>';
        html += '<table border="0" cellpadding="3" width="800">';
        html += thX('#', 'pc',  'function', 'sp');
        const desc_str = (v) => {
            let fName = v['function_name'];
            if (fName == null || fName == "") {
                fName = "(anonymous)";
            }
            let sArgs = "";
            v['args'].forEach((el, idx) => {
                if (idx != 0) {
                    sArgs += ", ";
                }
                sArgs += el[0] + "=" + el[1];
            });
            let sPos = "";
            if (v['position'] && v['position'][0] != null) {
                sPos = 'at ' + v['position'][0] + ':' + v['position'][1];
            }
            if (fName[0] == '<') {
                return fName;
            }
            return `${fName} (${sArgs}) ${sPos}`;
        };

        x.forEach((el, idx) => {
            let desc = escapeHtml(desc_str(el));
            html += tdX(`#${idx} `, el['pc'].toString(16), desc, el['sp'].toString(16));
        });
        html += '</table><br />';
        return html;
    }

    rAndbEnviron(xpath, title) {
        const x = xp(this.tsr, xpath);
        if (x == undefined) return "";
        let html = `<h2 id="${toTag(title)}">${title}</h2>`;
        html += '<table border="0" cellpadding="3" style="word-wrap:break-word; word-break:break-all;" width="800">';
        x.forEach((el, idx) => {
            html += tdX(idx, el);
        });
        html += '</table><br />';
        return html;
    }
    
    rV8Heap(x, title) {
        let html = '';
        html += '<table border="0" cellpadding="4" style="word-wrap:break-word; word-break:break-all;" width="600">';
        html += thX('Space Name', 'Committed Size', 'Max Committed', 'Pages Count', 'Pages Size');
        let total_commit = 0, total_pages = 0, total_pages_size = 0;
        x['spaces'].forEach((el, idx) => {
            let pages_size = 0;
            el['pages'].forEach((p) => {
                this.mMapNote(p['address'], p['address']+p['size'], `${title}.heap`);
                pages_size += parseInt(p['size'])
            });
            html += tdX(el['name'], el['committed'], el['max_committed'], el['pages'].length, pages_size);
            total_commit += parseInt(el['committed']);
            total_pages += el['pages'].length;
            total_pages_size += pages_size;
        });
        html += tdX('Total Memory Size', total_commit, '', total_pages, total_pages_size);
        html += '</table>';
        return html;
    }
   
    rIsolates() {
        const x = xp(this.tsr, 'andb/isolates');
        if (x == undefined) return "";
        let html = `<h2 id="isolates">Isolate Details</h2>`
        x.forEach((el, idx) => {
            let title = `Isolate:${el['id']}`
            html += `<h3>${title} @${el['address'].toString(16)}</h3>`;
            html += '<table border="0" cellpadding="2" style="word-wrap:break-word; word-break:break-all;" width="400">';
            html += tdX('ID', el['id']);
            html += tdX('Address', hex(el['address']));
            html += tdX('External Memory Size', el['external_memory_size']);
            html += '</table><br />';
            html += this.rV8Heap(el['heap'], title);
        }); 
        html += '<br />';
        return html;
    }

    rAndb() {
        const tsr = this.tsr;
        let html = '<h1>Andb reveal</h1>';
        html += this.rAndbV8BackTrace();
        html += this.rIsolates();
        html += this.rAndbEnviron('andb/environ', 'Environ Variables');
        html += this.rAndbEnviron('andb/init_environ', 'Initial Environ Variables');
        return html;
    }
}

function LoadTsr(txt) {
    var html = '';
    tsr = new TSR(txt);
    html += tsr.rFile();
    html += tsr.rAndbNodeVersion();
    html += tsr.rAndb();
    html += tsr.rCore();
    document.querySelector('#navbar').style.display = 'block';
    return html;
}

document.querySelector("#tsr-input").addEventListener('change', function() {
    // files that user has chosen
    var files = this.files;
    if (files.length == 0) {
        alert('No file selected');
        return;
    }

    var file = files[0];
    var reader = new FileReader();
    reader.addEventListener('load', function(e) {
        var text = e.target.result;
        document.querySelector("#contents").innerHTML = LoadTsr(text);
        document.querySelector("#contents").style.display = 'block';
        document.querySelector("#tsr-input-label").style.display = 'block'; 
        document.querySelector("#load-box").style.display = 'none';
    });

    reader.addEventListener('error', function() {
        alert('Failed to read file.');
    });
    
    reader.readAsText(file);
});
</script>
</html> 
